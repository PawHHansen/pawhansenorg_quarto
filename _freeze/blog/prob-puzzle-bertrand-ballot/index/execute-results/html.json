{
  "hash": "0363a4ad5552df970a3b3ee5fddbcde3",
  "result": {
    "markdown": "---\ntitle: \"Summer Simulations: Exploring Bertrand's Ballot Problem with a Simulation Study\"\nauthor: \"Paw Hansen\"\ndate: '2024-06-11'\ncategories: [statistical analysis]\nimage: featured.jpg\ndescription: \"Use tidy simulation to solve a version of Bertrand's classic ballot problem\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Packages used in this post\"}\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(kableExtra)\ntheme_set(theme_minimal_grid())\n```\n:::\n\n\nBertrand's ballot problem is a fascinating challenge in probability theory, originally posed by French mathematician Joseph Bertrand. It asks: if two candidates, A and B, receive ùëù and ùëû votes respectively, what is the probability that A will stay ahead of B throughout the entire vote counting process? Traditionally, this problem uses absolute vote counts, but in this study, I'll tweak the problem slightly and use percentage points.\n\nThe goal is to simulate this problem using R, exploring how different vote distributions affect the probability of A staying ahead. \n\nTo begin, I will simulate one vote counting process by taking advantage of the `cumsum` function, which calculates the cumulative sum. Let's simulate a case where A gets 51 percent of the votes and B 49 percent. I also create a \"ballot box\", which contains 1s for Part A's votes and 0s for those of Party B. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\np <- 51 # Example of A's vote share\nq <- 100 - p # B's vote share follows from p\n\nvotes <- c(rep(1, p), rep(0, q)) # Ballot box w/ all votes. \n```\n:::\n\n\nNow I can create my first simulation by randomly drawing from the ballot box vector (`votes`). The variables `votes_for_a` and `votes_for_b` keep track of how many votes each party has received.  \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  sims <- \n    tibble(ballot = 1:length(votes)) |> \n    mutate(voted_a = sample(votes, length(votes))) |> \n    mutate(votes_for_a = cumsum(voted_a),\n           votes_for_b = cumsum(1 - voted_a))\n```\n:::\n\n\nThe resulting data looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nhead(sims)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 4\n  ballot voted_a votes_for_a votes_for_b\n   <int>   <dbl>       <dbl>       <dbl>\n1      1       1           1           0\n2      2       0           1           1\n3      3       0           1           2\n4      4       1           2           2\n5      5       1           3           2\n6      6       0           3           3\n```\n:::\n:::\n\n\nDid Party A stay ahead of Party B throughout the vote counting? \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nall(sims$votes_for_a > sims$votes_for_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nNo (which makes sense given a final majority of only one percent). \n\n### Simulating One Vote Count Using a Function\nLet us turn our initial code into a function to simulate the vote counting process. This function will help determine if A stays ahead throughout the count: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsimulate_votes <- function(p = 50, q = 100 - p) {\n  votes <- c(rep(1, p), rep(0, q)) # Ballot box w/ all votes\n  \n  sims <- \n    tibble(ballot = 1:length(votes)) |> \n    mutate(voted_a = sample(votes, length(votes))) |> \n    mutate(votes_for_a = cumsum(voted_a),\n           votes_for_b = cumsum(1 - voted_a))\n  \n  all(sims$votes_for_a > sims$votes_for_b)\n}\n\n# simulate_votes(p = 60) # Make sure the function works\n```\n:::\n\n\n### Running the Simulation\nNext, I run the simulation across multiple trials to obtain reliable probability estimates. I use the crossing function to create a tibble of all combinations of trials and values of ùëù. We then apply our simulation function to each value of ùëù and record whether A stayed ahead: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nrs <- \n  crossing(trial = 1:1000, \n           p = 50:100) |> \n  mutate(ahead = map_lgl(p, ~simulate_votes(p = .)))\n```\n:::\n\n\n### Analyzing the Results\nOne way of presenting the results is using a line graph to show the probability that A stays ahead throughout the vote count for different values of ùëù.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrs |> \n  group_by(p) |> \n  summarize(probability = mean(ahead)) |> \n  ggplot(aes(p, probability)) + \n  geom_line(size = 1, color = \"firebrick\") + \n  scale_y_continuous(labels = scales::percent_format()) + \n  labs(title = \"More votes, bigger chance of leading from start to finish\",\n       subtitle = \"Probability that Party A will be strictly ahead of B throughout the count\",\n       x = \"Party A' Vote Share\",\n       y = \"Probability of Staying Ahead\") + \n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\", size = 16),\n        plot.subtitle = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nThis plot shows that as the number of votes for A increases, the probability of A staying ahead throughout the count also increases.\n\nAnother approach would be to present the results in a table, focusing on specific values of \nùëù that might be of particular interest: \n\n\n::: {#tbl-prob-bertrand .cell tbl-cap='Probability of Party A staing ahead througout the vote counting for selected final vote shares'}\n\n```{.r .cell-code}\nrs |> \n  group_by(p) |> \n  summarize(probability = mean(ahead)) |> \n  filter(p %in% c(50, 75, 90, 100)) |>  \n  kable(col.names = c(\"Party A's final vote share\", \"Probability\"), \n    digits = 2) \n```\n\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> Party A's final vote share </th>\n   <th style=\"text-align:right;\"> Probability </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 50 </td>\n   <td style=\"text-align:right;\"> 0.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 75 </td>\n   <td style=\"text-align:right;\"> 0.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 90 </td>\n   <td style=\"text-align:right;\"> 0.81 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 100 </td>\n   <td style=\"text-align:right;\"> 1.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nThis table will show the probability of party A staying ahead for selected values of ùëù, providing a quick reference for key points in our simulation.\n\n### Conclusion\nThe above simulation study reveals that the likelihood of one party remaining ahead throughout the vote count significantly increases with a higher number of votes. This result is quite intuitive but simulation allows us to test if our intuition is correct as well as assigning specific probabilities to outcomes of interest. \n\nYou could complicate the simulation study by adding more parties or by allowing the probability of receiving a vote to vary throughout the vote count (so that Party A is more likely to receive its votes early on, for example).   \n\nHappy simulating!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}