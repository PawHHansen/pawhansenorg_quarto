{
  "hash": "696f8a925f51ae68fa94506d4e8b3869",
  "result": {
    "markdown": "---\ntitle: \"Summer Simulations: Solving the Marriage Problem Using Tidy Simulation\"\nauthor: \"Paw Hansen\"\ndate: '2024-06-12'\ncategories: [statistical analysis]\nimage: featured.jpg\ndescription: \"Use tidy simulation to solve a version the marriage problem!\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Packages used in this post\"}\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(kableExtra)\ntheme_set(theme_minimal_grid())\n```\n:::\n\nThe marriage problem, also known as the secretary problem, is a classic probability puzzle that allows us to study optimal stopping theory and decision-making under uncertainty.\n\nIt goes like this: Consider a woman who has ùëõ men willing to marry her. If all the men showed up at once, she could order them and choose the best. Unfortunately for her, the men arrive one at a time and in random order. After dating each man for a short period of time, she must decide, before moving on to the next, whether or not to marry him. If she rejects his marriage proposal, she cannot recall him at a later time and, should she decide to marry, she will have to forego meeting the remaining suitors. \n\nWhat strategy should she adopt if she wants to maximize the probability of marrying the best suitor?\n\nThis puzzle is an excellent example of a type of decision-making that requires some form of stopping rule: when should the woman \"stop playing\" and accept the suitor at hand? This type of puzzle extends to many other forms of decisions such as hiring employees, selling assets, and making investment choices. \n\n### Stopping Rule #1: Choosing at Random\nTo begin, consider a naive strategy: choosing at random. For example, knowing that she has 10 suitors, the woman rolls a fair 10-sided die and chooses the suitor corresponding to the number on the die (e.g. the fifth suitor to show up).\n\nHow often will that strategy lead to woman to marrying the optimal suitor? \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nn_men <- 10\nsuitors <- 1:n_men\n\nmean(replicate(1000, sample(suitors, n_men)) == n_men)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1\n```\n:::\n:::\n\n\nOn average, this strategy results in choosing the best suitor about 10% of the time - pretty bad odds if you ask me.  \n\nAlso, notice that this is equivalent to picking a specific position every time, such as always choosing the third suitor:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmean(replicate(10000, sample(suitors, n_men)[3]) == n_men)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1021\n```\n:::\n:::\n\n\n### Stopping Rule #2: Building on Baseline Knowledge\nA more sophisticated strategy would be using a training set to first establish a baseline before making a final selection. Here‚Äôs how it works:\n\n* Observe a set number of suitors (training set) without making a selection.\n* Set a cutoff based on the highest quality suitor in the training set.\n* Choose the first suitor in the test set who exceeds this cutoff.\n\nLet's implement this strategy in R:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nbaseline_choice <- function(n_men, n_train) {\n  \n  # Define suitors\n  suitors <- 1:n_men\n  \n  # Shuffle the suitors\n  suitors <- sample(suitors, n_men)\n  \n  # Split suitors into \"train\" and \"test\" sets\n  train <- suitors[1:n_train]\n  test <- suitors[(n_train + 1):n_men]\n  \n  # Define a cutoff\n  cutoff <- max(train)\n  \n  # Choose the first suitor greater than the cutoff\n  choice <- which(test > cutoff)[1]\n  \n  # If no suitor is found that is greater than the cutoff, choose the last one\n  if (is.na(choice)) {\n    return(suitors[n_men])  # Choose the last suitor in the original list\n  } else {\n    return(test[choice])\n  }\n}\n```\n:::\n\n\nTo make sure this function works, let's run a simulation with ten suitors with the first five being set aside for the training set:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nresults <- replicate(1000, baseline_choice(10, 5))\nmean(results == n_men)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.375\n```\n:::\n:::\n\n\nAlready much better odds than choosing at random. \n\nThe next question is of course what is the optimal number of suitors to set aside for the training set? We can look this number up on Wikipedia but simulation allows us to approximate the right number without knowing a lot of math. \n\nLet us rerun our simulation from before but this time with 100 suitors. Using the ever-useful `crossing` function and `map` we can study how the probability of choosing the best suitor varies with the number of suitors set aside. We'll do 10.0000 simulations: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nn_men <- 100\n\nsims <- \n  crossing(trial = 1:10000, \n         n_train = 1:99) |> \n  mutate(suitor_score = map_dbl(n_train, ~baseline_choice(n_men, .))) \n```\n:::\n\n\nAnd then calculate the probability: \n\n::: {#tbl-prob-marriage .cell tbl-cap='Probability of selecting the best suitor given size of training set'}\n\n```{.r .cell-code}\nrs <- \n  sims |> \n  group_by(n_train) |> \n  summarize(chose_mr_ten= mean(suitor_score == n_men)) |> \n  arrange(desc(chose_mr_ten))\n\nhead(rs) |> \n  kable(col.names = c(\"Number of suitors in training set\", \"Probaiblity\"), digits = 2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> Number of suitors in training set </th>\n   <th style=\"text-align:right;\"> Probaiblity </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 38 </td>\n   <td style=\"text-align:right;\"> 0.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 36 </td>\n   <td style=\"text-align:right;\"> 0.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 35 </td>\n   <td style=\"text-align:right;\"> 0.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 39 </td>\n   <td style=\"text-align:right;\"> 0.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 40 </td>\n   <td style=\"text-align:right;\"> 0.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 42 </td>\n   <td style=\"text-align:right;\"> 0.37 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWe can also visualize the success rate as a function of the training set size:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrs |> \n  ggplot(aes(n_train, chose_mr_ten)) + \n  geom_line(color = \"firebrick\", linewidth = 1) + \n  scale_y_continuous(labels = scales::percent_format()) + \n  labs(x = 'Number of Suitors in \"Training Set\"',\n       y = \"Probability of Choosing the Best Suitor\",\n       title = str_wrap(\"Using About One-Third of Suitors for Training Will Get You The Best Suitor in The End\", 60)) +\n  theme(plot.title = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### Conclusion\nThe optimal stopping rule in the marriage problem suggests that the woman should observe and reject roughly the first third of suitors, then marry the first suitor who is better than those she has previously observed.\n\nThis approach to solving the marriage problem showcases the power of simulation in understanding decision-making processes. Similar strategies can be applied to various real-world scenarios, such as hiring the best candidate, selling a house at the optimal price, or making investment decisions, where making the right choice is crucial and must be done with incomplete information.\n\nHappy simulating! \n\n### Cool! Where Can I Learn More? \n\n* David Robinson's blogpost on tidy simulation: http://varianceexplained.org/posts/ ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}